<?php

namespace Hametuha\HamePub\Parser;

use Hametuha\HamePub\Definitions\Mime;
use Hametuha\HamePub\Pattern\Application;
use Hametuha\HamePub\Oebps\Toc;
use Masterminds\HTML5;

/**
 * Parse HTML
 *
 * @package Hametuha\HamePub\Parser
 */
class HTML5Parser extends Application
{
    /**
     * @var HTML5
     */
    public $html5 = null;

    /**
     * @var array
     */
    protected $tag_deprecated = ['tt', 'big', 'acronym', 'abbr', 'strike'];

    /**
     * @var array
     */
    protected $tag_to_remove = ['colgroup'];

    /**
     * Constructor
     *
     * @param string $id
     */
    protected function __construct($id)
    {
        parent::__construct($id); // TODO: Change the autogenerated stub
        $this->html5 = new HTML5();
    }


    /**
     * Get HTML5 string
     *
     * @return string
     */
    public function convertToString($dom)
    {
        $html = $this->html5->saveHTML($dom);
        $html = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>' . "\n" . $html;
        // Library HTML5 always drop xmlns.
        $html = str_replace('<html', '<html xmlns="http://www.w3.org/1999/xhtml"', $html);
        // Convert entities
        $html = str_replace('&nbsp;', '&#160;', $html);
        // Remove srcset
        $html = preg_replace('/srcset="[^"]*"/', '', $html);
        // Remove rt
        $html = preg_replace('/<rp>[^<]*?<\/rp>/', '', $html);
        // Remove align
        $html = preg_replace('/align="(center|right|left)"/', 'class="text-$1"', $html);
        // fix close tag
        $html = preg_replace('/<(meta|link|img|br|param|hr)([^>]*)?>/u', '<$1$2 />', $html);
        return $html;
    }

    /**
     * Save Dom as XHTML file.
     *
     * @param \DOMDocument $dom
     * @param string $name
     *
     * @return bool|string
     */
    public function saveDom(\DOMDocument $dom, $name)
    {
        return $this->distributor->write($this->convertToString($dom), "OEBPS/Text/{$name}");
    }

    /**
     * Extract assets
     *
     * @param \DomDocument $dom
     * @param string $tag
     * @param string $attr
     * @param string $url_base URL base to be replaced with $doc_root
     * @param string $doc_root
     * @return array
     */
    public function extractAssets(\DomDocument &$dom, $tag, $attr, $url_base, $doc_root)
    {
        $paths = [];
        foreach ($dom->getElementsByTagName($tag) as $elem) {
            /** @var \DOMElement $elem */
            list($value) = explode('?', $elem->getAttribute($attr));
            if (preg_match($url_base, $value)) {
                $path = preg_replace($url_base, $doc_root, $value);
                if (file_exists($path)) {
                    $dir = 'Asset/';
                    $new_path = ltrim(str_replace($doc_root, $dir, $path), DIRECTORY_SEPARATOR);
                    $elem->setAttribute($attr, '../' . $new_path);
                    // If this is CSS, extract assets
                    if (false !== strpos($path, '.css')) {
                        // Load all url context and copy them
                        $css = preg_replace_callback('/url\w*?\(([^)]*)\)/', function ($matches) use ($path, $doc_root, $dir, &$paths) {
                            list($asset) = explode('?', ltrim(trim(trim($matches[1]), '"'), '/'));
                            $asset = realpath(dirname($path) . DIRECTORY_SEPARATOR . $asset);
                            if (file_exists($asset)) {
                                $asset_src = str_replace($doc_root, $dir, $asset);
                                if ($this->distributor->copy($asset, 'OEBPS/' . $asset_src)) {
                                    $paths[] = $asset_src;
                                }
                            }
                            return $matches[0];
                        }, file_get_contents($path));
                        // Save CSS
                        if ($this->distributor->write($css, 'OEBPS/' . $new_path)) {
                            $paths[] = $new_path;
                        }
                    } else {
                        // Copy it
                        if ($this->distributor->copy($path, 'OEBPS/' . $new_path)) {
                            $paths[] = $new_path;
                        }
                    }
                }
            }
        }
        return $paths;
    }

    /**
     * Extract remote assets and save it
     *
     * @param \DomDocument $dom
     *
     * @return array
     */
    public function pullRemoteAssets(\DomDocument &$dom)
    {
        $paths = [];
        foreach (['img' => 'src', 'script' => 'src', 'link' => 'href'] as $tag => $attr) {
            foreach ($dom->getElementsByTagName($tag) as $elem) {
                /** @var \DOMElement $elem */
                $url = $elem->getAttribute($attr);
                if (!preg_match('/^(https?:)?\/\//', $url)) {
                    continue;
                }
                // Get remote resource
                if (!($resource = $this->getRemote($url))) {
                    continue;
                }
                // Let's detect file mime
                list($basename) = explode('?', basename($url));
                $dir = Mime::getDestinationFolder($basename);
                if ('Misc' === $dir) {
                    // Oh, it might not have extension...
                    if ($resource['info']) {
                        list($mime, $type) = explode('/', $resource['info']['content_type']);
                        list($ext) = explode(';', $type);
                        $new_dir = Mime::getDestinationFolder("hoge.{$ext}");
                        if ($new_dir != $dir) {
                            $dir = $new_dir;
                            $basename = "{$basename}.{$ext}";
                        }
                    }
                }
                // O.K.
                $new_path = $dir . '/' . $basename;
                $elem->setAttribute($attr, '../' . $new_path);
                if ($this->distributor->write($resource['body'], 'OEBPS/' . $new_path)) {
                    $paths[] = $new_path;
                }
            }
        }
        return $paths;
    }


    /**
     * @param Toc $toc
     * @param $dom
     * @param bool|true $add_id
     * @param int $max_depth
     * @param int $min_level
     *
     * @return array|Toc
     */
    public function grabHeaders(Toc &$toc, &$dom, $add_id = true, $max_depth = 3, $min_level = 1)
    {
        $headers = [];
        $max_depth = max(1, min($max_depth, 6));
        $min_level = max(1, $min_level);
        $xpath = new \DOMXPath($dom);

        $query = sprintf("//*[%s]", implode(' or ', array_map(function ($depth) {
            return sprintf("name()='h%d'", $depth);
        }, range($min_level, $max_depth))));
        $counter = 0;
        foreach ($xpath->query($query) as $header) {
            $counter++;
            /** @var \DomElement $header */
            $tag_level = intval(preg_replace('/[^0-9]/u', '', $header->tagName));
            if ($header->hasAttribute('id')) {
                $header_id = (string)$header->getAttribute('id');
            } else {
                $header_id = sprintf('header%d-%03d', $tag_level, $counter);
                if ($add_id) {
                    $header->setAttribute('id', $header_id);
                }
            }
            $headers[$header_id] = [
                'level' => $tag_level,
                'content' => $header->textContent,
                'children' => []
            ];
        }
        if (!$headers) {
            return [];
        }
        $arranged = [];
        foreach ($headers as $key => $header) {
            if (!$this->digToc($key, $header, $arranged)) {
                $arranged[$key] = $header;
            }
        }
        $this->recursiveToc($toc, $toc->link, $arranged);
        return $toc;
    }

    /**
     * Recursively add toc
     *
     * @param Toc $toc
     * @param string $src
     * @param array $headers
     */
    private function recursiveToc(Toc &$toc, $src, array $headers)
    {
        foreach ($headers as $id => $header) {
            $child = $toc->addChild($header['content'], $src . '#' . $id);
            if ($header['children']) {
                $this->recursiveToc($child, $src, $header['children']);
            }
        }
    }

    /**
     * Arrange toc elements
     *
     * @param string $id
     * @param array $header
     * @param array $headers
     *
     * @return bool
     */
    private function digToc($id, array $header, array &$headers)
    {
        $keys = array_keys($headers);
        krsort($keys);
        $done = false;
        foreach ($keys as $key) {
            if ($headers[$key]['level'] < $header['level']) {
                if (!$this->digToc($id, $header, $headers[$key]['children'])) {
                    $headers[$key]['children'][$id] = $header;
                }
                return true;
            }
        }
        return false;
    }

    /**
     * Get dom document from html segments.
     *
     * @param string $string
     *
     * @return \DOMDocument
     */
    public function getDomFromString($string)
    {
        // Convert DOM
        $xml = <<<HTML
<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8" />
</head>
<body>
{$string}
</body>
</html>
HTML;
        return $this->html5->loadHTML($xml);
    }

    /**
     * @param $dom
     *
     * @return null
     */
    public function retrieveBody($dom)
    {
        if (preg_match('/<body>(.*)<\/body>/s', $this->html5->saveHTML($dom), $match)) {
            return $match[1];
        } else {
            return null;
        }
    }

    /**
     * Convert xml
     *
     * @param string $content
     *
     * @return mixed
     */
    public function format($content)
    {
        // Add tcy
        $content = $this->tcyiz($content);
        // Add auto indent
        $dom = $this->getDomFromString($content);
        foreach ($dom->getElementsByTagName('p') as $p) {
            if (!$this->needIndent($p->nodeValue)) {
                $this->addClass($p, 'no-indent');
            }
        }
        // Change all disabled tags.
        $node_to_remove = array();
        foreach ($this->tag_deprecated as $tag) {
            foreach ($dom->getElementsByTagName($tag) as $elem) {
                /** @var \DOMElement $elem */
                $new_elem = $dom->createElement('span');
                // Copy all attributes
                if ($elem->attributes) {
                    foreach ($elem->attributes as $attr) {
                        $new_elem->setAttribute($attr->nodeName, $attr->nodeValue);
                    }
                }
                // Add original tag name as class
                $this->addClass($new_elem, $tag);
                // Copy all nodes
                foreach ($elem->childNodes as $child) {
                    $new_elem->appendChild($elem->removeChild($child));
                }
                $node_to_remove[] = $elem;
                $elem->parentNode->replaceChild($new_elem, $elem);
            }
        }
        // Remove all tags
        foreach ($this->tag_to_remove as $tag) {
            foreach ($dom->getElementsByTagName($tag) as $elem) {
                /** @var \DOMElement $elem */
                $elem->parentNode->removeChild($elem);
            }
        }
        // Remove
        return $this->retrieveBody($dom);
    }

    /**
     * Make string tcyed
     *
     * @param $string
     *
     * @return string
     */
    public function tcyiz($string)
    {
        // Add tcy
        $string = preg_replace_callback('#(?<=>|^|[^[:ascii:]/])([0-9a-zA-Z!?]{1,3})(?![[:ascii:]/])#u', function ($matches) {
            return sprintf('<span class="tcy">%s</span>', $matches[1]);
        }, $string);
        // Remove tcy in attribute
        $string = preg_replace_callback('#( [a-z\-0-9]+)="([^"]*<span class="tcy">.*(?!=tcy|class=))"#u', function ($matches) {
            $attr = str_replace('</span>', '', $matches[2]);
            $attr = str_replace('<span class="tcy">', '', $attr);
            return sprintf('%s="%s"', $matches[1], $attr);
        }, $string);
        return $string;
    }

    /**
     * Detect if auto-indent required
     *
     * @param string $string
     * @return bool
     */
    public function needIndent($string)
    {
        $first_letter = mb_substr($string, 0, 1, 'UTF-8');
        $match = !preg_match('/[ 　【《〔〝『「（”"\'’—\(\)]/u', $first_letter, $matches);
        return (bool)$match;
    }

    /**
     * Add class to element
     *
     * @param \DOMElement $node
     * @param array|string $classes
     */
    public function addClass(\DOMElement &$node, $classes)
    {
        $classes = (array)$classes;
        if ($node->hasAttribute('class')) {
            $classes = array_merge($classes, explode(' ', $node->getAttribute('classs')));
        }
        $node->setAttribute('class', implode(' ', $classes));
    }

    /**
     * Get remote assets
     *
     * @param string $url
     *
     * @return array|false
     */
    public function getRemote($url)
    {
        $ch = curl_init($url);
        curl_setopt_array($ch, [
            CURLOPT_RETURNTRANSFER => true,
            CURLOPT_TIMEOUT => 5,
            CURLOPT_SSL_VERIFYPEER => false,
            CURLOPT_FAILONERROR => true,
        ]);
        $result = curl_exec($ch);
        if (false === $result) {
            return false;
        }
        $return = [
            'info' => curl_getinfo($ch),
            'body' => $result,
        ];
        curl_close($ch);
        return $return;
    }

    /**
     * Parse HTML5 and convert to Dom document
     *
     * @param $string
     *
     * @return false|\DomDocument
     */
    public function parseFromString($string)
    {
        $dom = $this->html5->loadHTML($string);
        if (is_a($dom, 'DOMDocument')) {
            return $dom;
        } else {
            return false;
        }
    }
}
